if lisp == nil then
  lisp = {}
end

require 'lisp.parse'

-- local functions object
local _ = {}


-- raw token
function _.raw(symbol, position)
  if position == nil then
    position = ''
  end
  return {
    type     = 'raw',
    value    = symbol,
    position = position
  }
end

-- mutable merge
function _.mut_merge(...)
  local args = { ... }
  local first = args[1]
  local length = #args

  if length > 1 then
    for idx = 2, #args do
      local c_arg = args[idx]
      for k,v in pairs(c_arg) do
        table.insert(first, v)
      end
    end
  end

  return first
end

-- round value with parens when needed
function _.parens(value)
  if value.type ~= nil then
    return { value }
  else
    return _.mut_merge({ _.raw('(') }, value, { _.raw(')') })
  end
end

-- monadic maths
function _.monadic_math(op, a)
  return _.parens(_.mut_merge({ op }, { a }))
end

-- dyadic maths
function _.dyadic_math(a, op, b)
  return _.mut_merge(_.parens(a), { op }, _.parens(b))
end

-- operator
function _.operator(tk)
  local name  = tk.name
  local arity = lisp.macros_arity[name]
  if arity == 2 then
    local op = _.raw(' ' .. name .. ' ', tk.position)
    return _.dyadic_math(tk.value[1], op, tk.value[2])
  elseif arity == 1 then
    local op = _.raw(name .. ' ', tk.position)
    return _.monadic_math(op, tk.value[1])
  end
end


-- default macros
local macros = {
  ['+']  = 'op',
  ['-']  = 'op',
  ['/']  = 'op',
  ['*']  = 'op',
  ['^']  = 'op'
}

-- def macro
function macros.def(tk)
  local name  = tk.value[1]
  local value = {}

  for idx = 2, #tk.value do
    table.insert(value, tk.value[idx])
  end

  if #value == 1 then
    value = value[1]
  end

  return _.mut_merge(
    { _.raw('local ') },
    _.dyadic_math(
      name,
      _.raw(' = '),
      value
    ),
    { _.raw('\n') }
  )
end

-- let macro
function macros.let(tk)
  local output = {}

  local args   = {}
  local values = {}
  local length = #tk.value - 1

  for idx=1, length do
    if idx % 2 == 0 then
      if #values > 0 then
        table.insert(values, _.raw(', '))
      end
      _.mut_merge(values, _.parens(tk.value[idx]))
    else
      if #args > 0 then
        table.insert(args, _.raw(', '))
      end
      table.insert(args, tk.value[idx])
    end
  end

  table.print(tk)

  return _.mut_merge(
    { _.raw('(function(') }, args, { _.raw(')\n') },
    tk.value[length + 1], { _.raw('\nend)') },
    { _.raw('(') }, values, { _.raw(')\n') }
  )
end


-- lisp.build, the builder
function lisp.build(parseres, debug)
  if debug == nil then
    debug = true
  end

  if parseres.result.error then
    return {
      source = '',
      result = parseres.result
    }
  end

  local stack  = {}

  function merge(a, b)
    if type(b) == 'table' and b[1] ~= nil then
      for k,v in pairs(b) do table.insert(a, v) end
    else
      table.insert(a, b)
    end
  end

  function map(a, fn)
    local b = {}
    for idx = 1, #a do
      b[idx] = fn(a[idx])
    end
    return b
  end

  function analyze(curr)
    local ast = {}

    if curr.type == 'root' then
      table.insert(ast, {
        type     = 'comment',
        value    = ' Generated by LuaS2Lisp@0.0.1 :3',
        position = '0:0'
      })

      map(curr.value, function(item) merge(ast, analyze(item)) end)
      return ast
    elseif curr.type == 'macro' then
      curr.value = map(curr.value, function(item)
        return analyze(item)
      end)


      local guide = macros[curr.name]

      if guide == 'op' then
        return _.mut_merge(ast, _.operator(curr))
      elseif type(guide) == 'function' then
        return _.mut_merge(ast, guide(curr))
      end

      return ast
    elseif curr.type == 'block' then
      map(curr.value, function(item)
        _.mut_merge(ast, analyze(item))
      end)

      return ast
    elseif curr.type == 'return' then
      _.mut_merge(
        ast,
        { _.raw('return ') },
        analyze(curr.value)
      )

      return  ast
    else
      return curr
    end
  end

  local output = {
    source = '',
    result = {
      error   = false,
      message = ''
    }
  }

  function line(str)
    output.source = output.source .. str .. '\n'
  end

  function raw(str)
    output.source = output.source .. str
  end


  local flat_tokens = analyze(parseres.ast)

  for idx = 1, #flat_tokens do
    local token = flat_tokens[idx]

    if token.type == 'comment' then
      line('--' .. token.value)
    elseif token.type == 'raw' or
           token.type == 'number' or
           token.type == 'literal' then
      raw(token.value)
    elseif token.type == 'astr' then
      raw("'" .. token.value .. "'")
    elseif token.type == 'bstr' then
      raw('"' .. token.value .. '"')
    end
  end

  return output
end

--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

table.print = function(t)
  local print_r_cache={}
  local function sub_print_r(t,indent)
    if (print_r_cache[tostring(t)]) then
      print(indent.."*"..tostring(t))
    else
      print_r_cache[tostring(t)]=true
      if (type(t)=="table") then
        for pos,val in pairs(t) do
          if (type(val)=="table") then
            print(indent.."["..pos.."] => "..tostring(t).." {")
            sub_print_r(val,indent..string.rep(" ",string.len(pos)+8))
            print(indent..string.rep(" ",string.len(pos)+6).."}")
          elseif (type(val)=="string") then
            print(indent.."["..pos..'] => "'..val..'"')
          else
            print(indent.."["..pos.."] => "..tostring(val))
          end
        end
      else
        print(indent..tostring(t))
      end
    end
  end
  if (type(t)=="table") then
    print(tostring(t).." {")
    sub_print_r(t,"  ")
    print("}")
  else
    sub_print_r(t,"  ")
  end
  print()
end
