if lisp == nil then
  lisp = {}
end

-- local functions object
local _ = {}

-- raw token
function _.raw(symbol, position)
  if position == nil then
    position = ''
  end
  return {
    type     = 'raw',
    value    = symbol,
    position = position
  }
end

-- mutable merge
function _.mut_merge(...)
  local args = { ... }
  local first = args[1]
  local length = #args

  if length > 1 then
    for idx = 2, #args do
      local c_arg = args[idx]
      for k,v in pairs(c_arg) do
        table.insert(first, v)
      end
    end
  end

  return first
end

-- round value with parens when needed
function _.parens(value)
  if value.type ~= nil then
    return { value }
  else
    return _.mut_merge({ _.raw('(') }, value, { _.raw(')') })
  end
end

-- monadic maths
function _.monadic_math(op, a)
  return _.parens(_.mut_merge({ _.raw(op) }, _.parens(a)))
end

-- dyadic maths
function _.dyadic_math(a, root, b)
  return _.parens(
    _.mut_merge(
      _.parens(a),
      { _.operator(root) },
      _.parens(b)
    )
  )
end

-- operator
function _.operator(tk)

  table.print(tk)
  return { ' e'}
end


-- default macros
local macros = {
  ['+'] = function (root, a, b)
    return _.dyadic_math(a, root, b)
    --[[
    local output = {}

    if a.type ~= nil then
      table.insert(output, a)
    else
      merge_parens(output, a)
    end


    table.insert(output, _.raw_tk(' + '))

    if b.type ~= nil then
      table.insert(output, b)
    else
      merge_parens(output, b)
    end

    return output]]
  end
}

-- lisp.build, the builder
function lisp.build(parseres)
  if parseres.result.error then
    return parseres
  end

  local stack  = {}

  function merge(a, b)
    if type(b) == 'table' and b[1] ~= nil then
      for k,v in pairs(b) do table.insert(a, v) end
    else
      table.insert(a, b)
    end
  end

  function map(a, fn)
    local b = {}
    for idx = 1, #a do
      b[idx] = fn(a[idx])
    end
    return b
  end

  function analyze(curr)
    local ast = {}

    if curr.type == 'root' then
      table.insert(ast, {
        type     = 'comment',
        value    = ' Generated by LuaS2Lisp@0.0.1 :3',
        position = '0:0'
      })

      map(curr.value, function(item) merge(ast, analyze(item)) end)
      return ast
    elseif curr.type == 'macro' then
      local args = map(curr.value, function(item)
        return analyze(item)
      end)

      local guide = macros[curr.name]

      if (guide == '')
      merge(ast, (unpack(args)))
      return ast
    else
      return curr
    end
  end

  local flat_ast = analyze(parseres.ast)
  print('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')
  table.print(flat_ast)
  return flat_ast
end

--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

table.print = function(t)
  local print_r_cache={}
  local function sub_print_r(t,indent)
    if (print_r_cache[tostring(t)]) then
      print(indent.."*"..tostring(t))
    else
      print_r_cache[tostring(t)]=true
      if (type(t)=="table") then
        for pos,val in pairs(t) do
          if (type(val)=="table") then
            print(indent.."["..pos.."] => "..tostring(t).." {")
            sub_print_r(val,indent..string.rep(" ",string.len(pos)+8))
            print(indent..string.rep(" ",string.len(pos)+6).."}")
          elseif (type(val)=="string") then
            print(indent.."["..pos..'] => "'..val..'"')
          else
            print(indent.."["..pos.."] => "..tostring(val))
          end
        end
      else
        print(indent..tostring(t))
      end
    end
  end
  if (type(t)=="table") then
    print(tostring(t).." {")
    sub_print_r(t,"  ")
    print("}")
  else
    sub_print_r(t,"  ")
  end
  print()
end
