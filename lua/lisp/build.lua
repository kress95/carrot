if lisp == nil then
  lisp = {}
end

require 'lisp.parse'

-- local functions object
local _ = {}

-- raw token
function _.raw(symbol, position)
  if position == nil then
    position = ''
  end
  return {
    type     = 'raw',
    value    = symbol,
    position = position
  }
end

-- mutable merge
function _.mut_merge(...)
  local args = { ... }
  local first = args[1]
  local length = #args

  if length > 1 then
    for idx = 2, #args do
      local c_arg = args[idx]
      for k,v in pairs(c_arg) do
        table.insert(first, v)
      end
    end
  end

  return first
end

-- round value with parens when needed
function _.parens(value)
  if value.type ~= nil then
    return { value }
  else
    return _.mut_merge({ _.raw('(') }, value, { _.raw(')') })
  end
end

-- monadic maths
function _.monadic_math(op, a)
  return _.parens(_.mut_merge({ op }, { a }))
end

-- dyadic maths
function _.dyadic_math(a, op, b)
  return _.mut_merge(_.parens(a), { op }, _.parens(b))
end

-- operator
function _.operator(tk)
  local name  = tk.name
  local arity = lisp.macros_arity[name]
  if arity == 2 then
    local op = _.raw(' ' .. name .. ' ', tk.position)
    return _.dyadic_math(tk.value[1], op, tk.value[2])
  elseif arity == 1 then
    local op = _.raw(name .. ' ', tk.position)
    return _.monadic_math(op, tk.value[1])
  end
end


-- default macros
local macros = {
  ['+']  = 'op',
  ['-']  = 'op',
  ['/']  = 'op',
  ['*']  = 'op',
  ['^']  = 'op'

  --[[['+'] = function (root, a, b)
    return _.dyadic_math(a, root, b)
    --[[
    local output = {}

    if a.type ~= nil then
      table.insert(output, a)
    else
      merge_parens(output, a)
    end


    table.insert(output, _.raw_tk(' + '))

    if b.type ~= nil then
      table.insert(output, b)
    else
      merge_parens(output, b)
    end

    return output
  end]]
}

-- lisp.build, the builder
function lisp.build(parseres, debug)
  if debug == nil then
    debug = true
  end

  if parseres.result.error then
    return {
      source = '',
      result = parseres.result
    }
  end

  local stack  = {}

  function merge(a, b)
    if type(b) == 'table' and b[1] ~= nil then
      for k,v in pairs(b) do table.insert(a, v) end
    else
      table.insert(a, b)
    end
  end

  function map(a, fn)
    local b = {}
    for idx = 1, #a do
      b[idx] = fn(a[idx])
    end
    return b
  end

  function analyze(curr)
    local ast = {}

    if curr.type == 'root' then
      table.insert(ast, {
        type     = 'comment',
        value    = ' Generated by LuaS2Lisp@0.0.1 :3',
        position = '0:0'
      })

      map(curr.value, function(item) merge(ast, analyze(item)) end)
      return ast
    elseif curr.type == 'macro' then
      curr.value = map(curr.value, function(item)
        return analyze(item)
      end)

      local guide = macros[curr.name]

      if guide == 'op' then
        return _.mut_merge(ast,_.operator(curr))
      end

      return ast
    else
      return curr
    end
  end

  local output = {
    source = '',
    result = {
      error   = false,
      message = ''
    }
  }

  function line(str)
    output.source = output.source .. str .. '\n'
  end

  function raw(str)
    output.source = output.source .. str
  end

  local flat_tokens = analyze(parseres.ast)

  for idx = 1, #flat_tokens do
    local token = flat_tokens[idx]

    if token.type == 'comment' then
      line('--' .. token.value)
    elseif token.type == 'raw' or
           token.type == 'number' then
      raw(token.value)
    end
  end

  return output
end

--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

table.print = function(t)
  local print_r_cache={}
  local function sub_print_r(t,indent)
    if (print_r_cache[tostring(t)]) then
      print(indent.."*"..tostring(t))
    else
      print_r_cache[tostring(t)]=true
      if (type(t)=="table") then
        for pos,val in pairs(t) do
          if (type(val)=="table") then
            print(indent.."["..pos.."] => "..tostring(t).." {")
            sub_print_r(val,indent..string.rep(" ",string.len(pos)+8))
            print(indent..string.rep(" ",string.len(pos)+6).."}")
          elseif (type(val)=="string") then
            print(indent.."["..pos..'] => "'..val..'"')
          else
            print(indent.."["..pos.."] => "..tostring(val))
          end
        end
      else
        print(indent..tostring(t))
      end
    end
  end
  if (type(t)=="table") then
    print(tostring(t).." {")
    sub_print_r(t,"  ")
    print("}")
  else
    sub_print_r(t,"  ")
  end
  print()
end
